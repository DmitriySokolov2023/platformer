sumPowRec :: Double -> Int -> Double
sumPowRec n p =
  case p of -- сначала берем p и разбираем базовые случае
    0 -> 0 -- если кол-во элементов = 0, то вернем 0
    k | k > 0 -> -- создаем новое определение для p. p=k и если k > 0, то переходим к ветке case n ->
        case n of
          0 -> error "Ошибка, основание = 0" -- исключаем случай с n = 0 (он не имеет смысла)
          1 -> fromIntegral k -- если n = 1, то просто вернем кол-во элементов преобразовав в Double, тк 1^-i = 1 при любом i
          _ -> sumPowRec n (k - 1) + (n ^^ (-k)) -- во всех остальных случаях вызываем рекурсию | ^^ - используется вместо ^ тк корректно работает с отрицательными степенями
    _ -> error "p < 0" --ошибка ветки case p, если p < 0