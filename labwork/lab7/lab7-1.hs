data Tree a = Node a [Tree a] -- объявление нового типа данных (дерево может хранить любые типы a (Int, Char и тд))
  deriving (Show, Eq) --генерация стандартных возможностей (можем сравнивать деревья и печатать в GHCi)


t :: Tree Char --создаем дерево t
t =
  Node 'A' --корень
    [ Node 'B' [Node 'D' [], Node 'E' []], --дети и их вложенные элементы (получается есть уровни 0-2)
      Node 'C' [Node 'F' []]
    ]

levelList :: Tree a -> Int -> [a] -- функция принимает дерево Tree a и номер уровня Int -> возвращает список узлов на этом уровне
levelList _ n | n < 0 = [] --если уровень отрицательный
levelList (Node x _) 0 = [x] -- n = 0 то вернем сам элемент, отбрасываем детей
levelList (Node _ children) n = --отбрасываем корень и n>0
  concatMap (\sub -> levelList sub (n - 1)) children --используем concatMap тк с map будет несоответствие типов (map вернет список списков)



